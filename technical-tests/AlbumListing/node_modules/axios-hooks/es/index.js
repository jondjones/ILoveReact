import _extends from "@babel/runtime/helpers/esm/extends.js";
import _regeneratorRuntime from "@babel/runtime/regenerator/index.js";
import React from 'react';
import StaticAxios from 'axios';
import LRU from 'lru-cache';
var actions = {
  REQUEST_START: 'REQUEST_START',
  REQUEST_END: 'REQUEST_END'
};
var defaultUseAxios = makeUseAxios();
var __ssrPromises = defaultUseAxios.__ssrPromises,
    resetConfigure = defaultUseAxios.resetConfigure,
    configure = defaultUseAxios.configure,
    loadCache = defaultUseAxios.loadCache,
    serializeCache = defaultUseAxios.serializeCache;
export default defaultUseAxios;
export { __ssrPromises, resetConfigure, configure, loadCache, serializeCache };
export function makeUseAxios(configurationOptions) {
  var cache;
  var axiosInstance;
  var __ssrPromises = [];

  function resetConfigure() {
    cache = new LRU();
    axiosInstance = StaticAxios;
  }

  resetConfigure();

  function configure(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.axios) {
      axiosInstance = options.axios;
    }

    if (options.cache) {
      cache = options.cache;
    }
  }

  configure(configurationOptions);

  function loadCache(data) {
    cache.load(data);
  }

  function serializeCache() {
    var ssrPromisesCopy;
    return _regeneratorRuntime.async(function serializeCache$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ssrPromisesCopy = [].concat(__ssrPromises);
            __ssrPromises.length = 0;
            _context.next = 4;
            return _regeneratorRuntime.awrap(Promise.all(ssrPromisesCopy));

          case 4:
            return _context.abrupt("return", cache.dump());

          case 5:
          case "end":
            return _context.stop();
        }
      }
    });
  }

  return Object.assign(useAxios, {
    __ssrPromises: __ssrPromises,
    resetConfigure: resetConfigure,
    configure: configure,
    loadCache: loadCache,
    serializeCache: serializeCache
  });

  function cacheAdapter(config) {
    var cacheKey, hit, response, responseForCache;
    return _regeneratorRuntime.async(function cacheAdapter$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cacheKey = JSON.stringify(config);
            hit = cache.get(cacheKey);

            if (!hit) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", hit);

          case 4:
            delete config.adapter;
            _context2.next = 7;
            return _regeneratorRuntime.awrap(axiosInstance(config));

          case 7:
            response = _context2.sent;
            responseForCache = _extends({}, response);
            delete responseForCache.config;
            delete responseForCache.request;
            cache.set(cacheKey, responseForCache);
            return _context2.abrupt("return", response);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    });
  }

  function createInitialState(options) {
    return {
      loading: !options.manual
    };
  }

  function reducer(state, action) {
    var _extends2;

    switch (action.type) {
      case actions.REQUEST_START:
        return _extends({}, state, {
          loading: true,
          error: null
        });

      case actions.REQUEST_END:
        return _extends({}, state, {
          loading: false
        }, action.error ? {} : {
          data: action.payload.data
        }, (_extends2 = {}, _extends2[action.error ? 'error' : 'response'] = action.payload, _extends2));

      default:
        return state;
    }
  }

  function request(config, dispatch) {
    var response;
    return _regeneratorRuntime.async(function request$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            dispatch({
              type: actions.REQUEST_START
            });
            _context3.next = 4;
            return _regeneratorRuntime.awrap(axiosInstance(config));

          case 4:
            response = _context3.sent;
            dispatch({
              type: actions.REQUEST_END,
              payload: response
            });
            return _context3.abrupt("return", response);

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](0);

            if (!StaticAxios.isCancel(_context3.t0)) {
              _context3.next = 13;
              break;
            }

            return _context3.abrupt("return");

          case 13:
            dispatch({
              type: actions.REQUEST_END,
              payload: _context3.t0,
              error: true
            });
            throw _context3.t0;

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, null, null, [[0, 9]]);
  }

  function executeRequestWithCache(config, dispatch) {
    return request(_extends({}, config, {
      adapter: cacheAdapter
    }), dispatch);
  }

  function executeRequestWithoutCache(config, dispatch) {
    return request(config, dispatch);
  }

  function executeRequest(config, options, dispatch) {
    if (options.useCache) {
      return executeRequestWithCache(config, dispatch);
    }

    return executeRequestWithoutCache(config, dispatch);
  }

  function useAxios(config, options) {
    if (typeof config === 'string') {
      config = {
        url: config
      };
    }

    var stringifiedConfig = JSON.stringify(config);
    options = _extends({
      manual: false,
      useCache: true
    }, options);
    var cancelSourceRef = React.useRef();

    var _React$useReducer = React.useReducer(reducer, createInitialState(options)),
        state = _React$useReducer[0],
        dispatch = _React$useReducer[1];

    if (typeof window === 'undefined' && !options.manual) {
      useAxios.__ssrPromises.push(axiosInstance(_extends({}, config, {
        adapter: cacheAdapter
      })));
    }

    React.useEffect(function () {
      cancelSourceRef.current = StaticAxios.CancelToken.source();

      if (!options.manual) {
        executeRequest(_extends({
          cancelToken: cancelSourceRef.current.token
        }, config), options, dispatch)["catch"](function () {});
      }

      return function () {
        return cancelSourceRef.current.cancel();
      }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stringifiedConfig]);
    var refetch = React.useCallback(function (configOverride, options) {
      return executeRequest(_extends({
        cancelToken: cancelSourceRef.current.token
      }, config, {}, configOverride), _extends({
        useCache: false
      }, options), dispatch);
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [stringifiedConfig]);
    return [state, refetch];
  }
}